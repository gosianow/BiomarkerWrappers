
#' Maximum height of text
#' 
#' @export
wrapper_max_text_height <- function(text, fontsize = 12, rot = 0, wrap_width = NULL, unit = "inches"){
  
  if(!is.null(wrap_width)){
    text <- stringr::str_wrap(text, width = wrap_width)
  }
  
  out <- grid::convertUnit(ComplexHeatmap::max_text_height(text, gp = grid::gpar(fontsize = fontsize), rot = rot), unit)
  
  as.numeric(out)
  
}


#' Maximum width of text
#' 
#' @export
wrapper_max_text_width <- function(text, fontsize = 12, rot = 0, wrap_width = NULL, unit = "inches"){
  
  if(!is.null(wrap_width)){
    text <- stringr::str_wrap(text, width = wrap_width)
  }
  
  out <- grid::convertUnit(ComplexHeatmap::max_text_width(text, gp = grid::gpar(fontsize = fontsize), rot = rot), unit)
  
  as.numeric(out)
  
}



#' Check if a vector consists of valid names
#' 
#' @export
isValidAndUnreservedName <- function(x){
  all(make.names(x) == x)
}


#' Load content from a CSV file into an eSet 
#' 
#' @export
csv2eSet <- function(file, skip_ncol, skip_nrow, sep = "\t"){
  
  
  x <- read.table(file, header = FALSE, sep = sep, as.is = TRUE)
  
  
  pdata_matrix <- x[1:(skip_nrow), -(1:skip_ncol)]
  
  
  pdata <- data.frame(t(pdata_matrix[, -1]), stringsAsFactors = FALSE)
  colnames(pdata) <- gsub(":$", "", pdata_matrix[, 1])
  
  
  
  expr <- as.matrix.data.frame(mutate_all(x[-(1:(skip_nrow + 1)), -(1:(skip_ncol + 1))], as.numeric))
  
  colnames(expr) <- x[skip_nrow + 1, -(1:(skip_ncol + 1))]
  rownames(expr) <- x[-(1:(skip_nrow + 1)), skip_ncol + 1]
  
  
  fdata <- x[-(1:(skip_nrow + 1)), 1:(skip_ncol + 1)]
  
  colnames(fdata) <- x[skip_nrow + 1, 1:(skip_ncol + 1)]
  
  
  es <- ExpressionSet(assayData = expr)
  
  pData(es) <- pdata
  
  fData(es) <- fdata
  
  colnames(es) <- colnames(expr)
  
  es
  
  
}









#' Use round or signif
#' 
#' @keywords internal
round_signif <- function(x, digits = 2){
  ifelse(abs(x) >= 1, round(x, digits = digits), signif(x, digits = digits))
}




#' Save content of an eSet into a CSV file 
#' 
#' @export
eSet2csv <- function(es, file, digits = 2){
  
  fdata <- Biobase::fData(es)
  pdata <- Biobase::pData(es)
  expr <- round_signif(Biobase::exprs(es), digits = digits)
  
  
  if(!all(colnames(expr) == pdata[, 1])){
    stop("Column names of expression must be the same as the fisrt column in pData.")
  }
  
  
  ## Prepare the top table
  if(ncol(pdata) == 0){
    top_table <- data.frame()
  }else{
    top_table <- cbind(matrix("", nrow = ncol(pdata), ncol = ncol(fdata)), colnames(pdata), t(pdata))
  }
  
  utils::write.table(top_table, file = file, sep = ",", quote = TRUE, row.names = FALSE, col.names = FALSE, append = FALSE)
  
  ## Add empty row
  if(nrow(top_table) > 0){
    utils::write.table("", file = file, sep = ",", quote = TRUE, row.names = FALSE, col.names = FALSE, append = TRUE)
  }
  
  ## Prepare bottom table
  
  bottom_header <- t(c(colnames(fdata), "", colnames(expr)))
  
  utils::write.table(bottom_header, file = file, sep = ",", quote = TRUE, row.names = FALSE, col.names = FALSE, append = TRUE)
  
  bottom_table <- data.frame(fdata, "", as.data.frame.matrix(expr), stringsAsFactors = FALSE, check.names = FALSE)
  
  utils::write.table(bottom_table, file = file, sep = ",", quote = TRUE, row.names = FALSE, col.names = FALSE, append = TRUE)
  
  
}



#' Helper function to rename plots generated by the code chunks
#' 
#' @description
#' This is how you use it: `knitr::opts_chunk$set(fig.process=fig.rename, fig.prefix="my_prefix", fig.suffix="my_suffix")`
#' 
#' 
#' @export
fig.rename <- function(path, options){
  
  path_new <- path
  
  if(length(options$fig.suffix) != 0 | length(options$fig.prefix) != 0){
    
    if(length(options$fig.suffix) != 0){
      path_new <- paste0(tools::file_path_sans_ext(path_new), "-", options$fig.suffix, ".", tools::file_ext(path_new))
    }
    
    if(length(options$fig.prefix) != 0){
      
      path_new <- file.path(dirname(path_new), paste0(options$fig.prefix, "-", basename(path_new)))
    }
    
    file.rename(from = path, to = path_new)
    
  }
  
  path_new
  
}



### Based on this AWESOME post http://michaeljw.com/blog/post/subchunkify/
### See https://stackoverflow.com/questions/15365829/dynamic-height-and-width-for-knitr-plots

# subchunkify <- function(g, fig_height=7, fig_width=5) {
#   g_deparsed <- paste0(deparse(
#     function() {g}
#   ), collapse = '')
#   
#   sub_chunk <- paste0("
#   `","``{r, fig.height=", fig_height, ", fig.width=", fig_width, ", echo=FALSE}",
#     "\n(", 
#     g_deparsed
#     , ")()",
#     "\n`","``
#   ")
#   
#   cat(knitr::knit(text = knitr::knit_expand(text = sub_chunk), quiet = TRUE))
# }





#' My version of subchunkify 
#' 
#' @description
#' The original function is taken from the blog post that is referenced on stack overflow https://stackoverflow.com/questions/15365829/dynamic-height-and-width-for-knitr-plots.
#' 
#' Remember to set chunk options to `results = "asis"`.
#' 
#' Also necessary to set for knit_child: `knitr::opts_knit$set(output.dir = getwd())`
#' 
#' 
#' @export
subchunkify <- function(g, fig.height = 5, fig.width = 6, fig.prefix = NULL, fig.suffix = NULL, chunk_name = NULL, envir = parent.frame(), display_subchunk = FALSE){


  # -----------------------------------------------------------------------
  # Some checks
  # -----------------------------------------------------------------------
  
  stopifnot(length(fig.height) == 1)
  stopifnot(fig.height > 0)
  
  stopifnot(length(fig.width) == 1)
  stopifnot(fig.width > 0)
  
  # -----------------------------------------------------------------------
  # Subchunkify
  # -----------------------------------------------------------------------
  
  g_deparsed <- paste0(deparse(substitute(g)), collapse = "")
  
  ### Make unique labels. In the end when using knit_child no need for unique labels. However, then chunk_name must be unique.
  # time <- paste0(gsub("[[:punct:] ]", "_", format(Sys.time())), "_", floor(runif(1) * 10000))
  time <- NULL
  
  sub_chunk <- paste0("\n```{r ", chunk_name, time, ", fig.height=", fig.height, ", fig.width=", fig.width, ", fig.process=fig.rename", ifelse(is.null(fig.prefix), ", fig.prefix=NULL", paste0(", fig.prefix='", fig.prefix, "'")), ifelse(is.null(fig.suffix), ", fig.suffix=NULL", paste0(", fig.suffix='", fig.suffix, "'")), ", echo=FALSE}\n",
    g_deparsed,
    "\n```\n")
  
  if(display_subchunk){
    cat(sub_chunk)
  }
  
  ### Using knit_child is essential. Otherwise, with knit() error about unique chunk names.
  
  cat(knitr::knit_child(text = sub_chunk, quiet = TRUE, envir = envir))
  
}








#' Calculate logFC for expression data that will be plotted in a heatmap 
#' 
#' @param x eSet object
#' @export
wrapper_calculate_sample_logFC <- function(x, comparison_var, subgroup_var = NULL){
  
  
  if(is.null(subgroup_var)){
    Biobase::pData(x)$dummy_subgroup_var <- factor("dummy_subgroup_var")
    subgroup_var <- "dummy_subgroup_var"
  }
  
  subgroup_levels <- levels(Biobase::pData(x)[, subgroup_var])
  
  comparison_levels <- levels(Biobase::pData(x)[, comparison_var])
  
  reference_level <- comparison_levels[1]
  
  tbl <- table(Biobase::pData(x)[, comparison_var])
  
  stopifnot(tbl[reference_level] > 0)
  
  
  expr_heatmap <- lapply(1:length(subgroup_levels), function(i){
    # i = 1
    
    x_sub <- x[, Biobase::pData(x)[, subgroup_var] == subgroup_levels[i]]
    
    expr_sub <- Biobase::exprs(x_sub)
    
    expr_lfc <- expr_sub - rowMeans(expr_sub[, Biobase::pData(x_sub)[, comparison_var] == reference_level], na.rm = TRUE)
    
    expr_lfc
    
    
  }) 
  
  
  expr_heatmap <- do.call("cbind", expr_heatmap)
  
  
  ### Bring the same sample order as in x
  
  expr_heatmap <- expr_heatmap[, colnames(Biobase::exprs(x)), drop = FALSE]
  
  ### Return an eSet
  
  out <- Biobase::ExpressionSet(assayData = expr_heatmap, 
    phenoData = Biobase::phenoData(x), 
    featureData = Biobase::featureData(x))
  
  
  out
  
}




#' My version of cut
#' 
#' @export
cut2 <- function(x, breaks, labels = NULL, right = TRUE, dig.lab = 3){
  
  breaks_orig <- breaks
  
  breaks <- c(min(x, na.rm = TRUE) - 1, breaks_orig, max(x, na.rm = TRUE) + 1)
  
  
  if(is.null(labels)){
    
    labels <- levels(cut(1, breaks = breaks, labels = NULL, right = right, dig.lab = dig.lab))
    
    lower_number <- gsub("\\)|\\]", "", strsplit(labels[1], split = ",")[[1]][2])
    upper_number <- gsub("\\(|\\[", "", strsplit(labels[length(labels)], split = ",")[[1]][1])
    
    lower_label <- paste0(ifelse(right, "<=", "<"), lower_number)
    upper_label <- paste0(ifelse(right, ">", ">="), upper_number)
    
    
    labels[1] <- lower_label
    labels[length(labels)] <- upper_label
    
  }
  
  out <- cut(x, breaks = breaks, labels = labels, right = right, dig.lab = dig.lab)
  
  
}




#' My version of duplicated
#' 
#' @export
duplicated2 <- function(x, value = FALSE, na.rm = FALSE){
  
  if(is.factor(x)){
    x <- as.character(x)
  }
  
  ### Make the NAs to count as unique
  if(na.rm){
    x[is.na(x)] <- paste0("X...NA...", 1:sum(is.na(x)))
  }
  
  ifduplicated <- duplicated(x, fromLast = FALSE) | duplicated(x, fromLast = TRUE)
  
  if(value){
    out <- x[ifduplicated]
  }else{
    out <- ifduplicated
  }
  
  return(out)
  
}



#' My version of order for data frame
#' 
#' @param x Data frame
#' @export
order2 <- function(x, na.last = TRUE, decreasing = FALSE){
  
  stopifnot(is.data.frame(x))
  
  n <- ncol(x)
  
  if(length(na.last) == 1){
    na.last <- rep(na.last, n)
  }else{
    stopifnot(length(na.last) == n)  
  }
  
  if(length(decreasing) == 1){
    decreasing <- rep(decreasing, n)
  }else{
    stopifnot(length(decreasing) == n)  
  }
  
  
  new_order <- seq_len(nrow(x))
  
  for(i in rev(seq_len(n))){
    # i = 1
    
    oo <- order(x[new_order, i], na.last = na.last[i], decreasing = decreasing[i])
    
    new_order <- new_order[oo]
    
  }
  
  return(new_order)
  
}







#' Calculate number of non-NA elements in a vector 
#' 
#' @keywords internal
length_nonNA <- function(x){
  sum(!is.na(x))
}




#' Read gmt file and return a list of genes
#' 
#' @export
wrapper_read_gmt <- function(filename){
  x <- GSEABase::getGmt(filename)
  x <- GSEABase::geneIds(x)
  return(x)
}


#' Write a list of genes into a gmt file
#' 
#' @export
wrapper_write_gmt <- function(x, filename){
  
  gsc <- GSEABase::GeneSetCollection(lapply(1:length(x), function(i){
    # i = 1
    GSEABase::GeneSet(setName = names(x[i]), geneIds = x[[i]])
    
  }))
  
  GSEABase::toGmt(gsc, filename)
  
  invisible(NULL)
  
}









#' Spit a list of plots into chunks and plot them in a grid layout
#' 
#' @export
wrapper_print_plot_grid <- function(plotlist, nsplit = NULL, ncol = 2, nrow = NULL){
  
  if(is.null(nsplit)){
    nsplit <- length(plotlist)
  }
  
  indx <- seq_along(plotlist)
  indx_split <- split(indx, ceiling(seq_along(indx) / nsplit))
  
  for(i in seq_along(indx_split)){
    print(plot_grid(plotlist = plotlist[indx_split[[i]]], ncol = ncol, nrow = nrow))
  }
  
  # invisible()
  
}



#' Stratify data into quintiles
#' 
#' @param x Vector of continuous values to cut.
#' 
#' @export
wrapper_cut_quintiles <- function(x, labels = NULL, right = TRUE){
  
  if(is.null(labels)){
    if(right){
      labels <- c("[0%, 20%]", "(20%, 40%]", "(40%, 60%]", "(60%, 80%]", "(80%, 100%]")
    }else{
      labels <- c("[0%, 20%)", "[20%, 40%)", "[40%, 60%)", "[60%, 80%)", "[80%, 100%]")
    }
  }
  
  stopifnot(length(labels) == 5)
  
  out <- NULL
  
  try(out <- ggplot2::cut_number(x, n = 5, right = right), silent = TRUE)
  
  if(!is.null(out)){
    out <- factor(out, labels = labels)
  }else{
    out <- rep(NA, length(x))
  }
  
  return(out)
  
}



#' Stratify data into quartiles
#' 
#' @param x Vector of continuous values to cut.
#' 
#' @export
wrapper_cut_quartiles <- function(x, labels = NULL, right = TRUE){
  
  if(is.null(labels)){
    if(right){
      labels <- c("[0%, 25%]", "(25%, 50%]", "(50%, 75%]", "(75%, 100%]")
    }else{
      labels <- c("[0%, 25%)", "[25%, 50%)", "[50%, 75%)", "[75%, 100%]")
    }
  }
  
  stopifnot(length(labels) == 4)
  
  out <- NULL
  
  try(out <- ggplot2::cut_number(x, n = 4, right = right), silent = TRUE)
  
  if(!is.null(out)){
    out <- factor(out, labels = labels)
  }else{
    out <- rep(NA, length(x))
  }
  
  return(out)
  
}


#' Stratify data into tertiles
#' 
#' @param x Vector of continuous values to cut.
#' 
#' @export
wrapper_cut_tertiles <- function(x, labels = NULL, right = TRUE){
  
  if(is.null(labels)){
    labels <- c("low", "mid", "high")
  }
  
  stopifnot(length(labels) == 3)
  
  out <- NULL
  
  try(out <- ggplot2::cut_number(x, n = 3, right = right), silent = TRUE)
  
  if(!is.null(out)){
    out <- factor(out, labels = labels)
  }else{
    out <- rep(NA, length(x))
  }
  
  return(out)
  
}



#' Dichotomize data by median 
#' 
#' @param x Vector of continuous values to cut.
#' 
#' @export
wrapper_cut_median <- function(x, labels = NULL, right = TRUE){
  
  if(is.null(labels)){
    if(right){
      labels <- c("<=MED", ">MED")
    }else{
      labels <- c("<MED", ">=MED")
    }
  }
  
  stopifnot(length(labels) == 2)
  
  out <- NULL
  
  try(out <- ggplot2::cut_number(x, n = 2, right = right), silent = TRUE)
  
  if(!is.null(out)){
    out <- factor(out, labels = labels)
  }else{
    out <- rep(NA, length(x))
  }
  
  return(out)
  
}





#' Stratify data into two groups
#' 
#' @param x Vector of continuous values to cut.
#' 
#' @export
wrapper_cut_2groups <- function(x, probs = 0.5, cutoff = NULL, labels = NULL, right = TRUE){
  
  if(is.null(labels)){
    labels <- c("low", "high")
  }
  
  stopifnot(length(probs) == 1)
  stopifnot(length(labels) == 2)
  
  if(is.null(cutoff)){
    cutoff <- stats::quantile(x, probs = probs, na.rm = TRUE)
  }
  
  stopifnot(length(cutoff) == 1)
  
  if(right){
    out <- factor(ifelse(x <= cutoff, labels[1], labels[2]), levels = labels)
  }else{
    out <- factor(ifelse(x < cutoff, labels[1], labels[2]), levels = labels)
  }
  
  
  return(out)
  
}


#' @rdname wrapper_cut_quintiles
#' @export
wrapper_cut_quintiles_strat <- function(x, strata, labels = NULL, right = TRUE){
  
  stopifnot(is.factor(strata))
  
  strata_levels <- levels(strata)
  
  out <- wrapper_cut_quintiles(x, labels = labels, right = right)
  
  all_levels <- levels(out)
  
  out <- factor(rep(NA, length(x)), levels = all_levels)
  
  for(i in 1:length(strata_levels)){
    # i = 1
    
    indx_sub <- which(strata %in% strata_levels[i])
    
    out[indx_sub] <- wrapper_cut_quintiles(x[indx_sub], labels = labels, right = right)
    
  }
  
  return(out)
  
}


#' @rdname wrapper_cut_quartiles
#' @examples 
#' 
#' set.seed(123)
#' x <- sample.int(n = 100, replace = TRUE)
#' x
#' strata <- factor(rep(c("A", "B"), each = 50))
#' strata 
#' 
#' wrapper_cut_quartiles_strat(x = x, strata = strata)
#' 
#' @export
wrapper_cut_quartiles_strat <- function(x, strata, labels = NULL, right = TRUE){
  
  stopifnot(is.factor(strata))
  
  strata_levels <- levels(strata)
  
  out <- wrapper_cut_quartiles(x, labels = labels, right = right)
  
  all_levels <- levels(out)
  
  out <- factor(rep(NA, length(x)), levels = all_levels)
  
  for(i in 1:length(strata_levels)){
    # i = 1
    
    indx_sub <- which(strata %in% strata_levels[i])
    
    out[indx_sub] <- wrapper_cut_quartiles(x[indx_sub], labels = labels, right = right)
    
  }
  
  return(out)
  
}



#' @rdname wrapper_cut_tertiles
#' @export
wrapper_cut_tertiles_strat <- function(x, strata, labels = NULL, right = TRUE){
  
  stopifnot(is.factor(strata))
  
  strata_levels <- levels(strata)
  
  out <- wrapper_cut_tertiles(x, labels = labels, right = right)
  
  all_levels <- levels(out)
  
  out <- factor(rep(NA, length(x)), levels = all_levels)
  
  for(i in 1:length(strata_levels)){
    # i = 1
    
    indx_sub <- which(strata %in% strata_levels[i])
    
    out[indx_sub] <- wrapper_cut_tertiles(x[indx_sub], labels = labels, right = right)
    
  }
  
  return(out)
  
}



#' @rdname wrapper_cut_median
#' @export
wrapper_cut_median_strat <- function(x, strata, labels = NULL, right = TRUE){
  
  stopifnot(is.factor(strata))
  
  strata_levels <- levels(strata)
  
  out <- wrapper_cut_median(x, labels = labels, right = right)
  
  all_levels <- levels(out)
  
  out <- factor(rep(NA, length(x)), levels = all_levels)
  
  for(i in 1:length(strata_levels)){
    # i = 1
    
    indx_sub <- which(strata %in% strata_levels[i])
    
    out[indx_sub] <- wrapper_cut_median(x[indx_sub], labels = labels, right = right)
    
  }
  
  return(out)
  
}



#' @rdname wrapper_cut_2groups
#' @export
wrapper_cut_2groups_strat <- function(x, strata, probs = rep(0.5, nlevels(strata)), cutoff = NULL, labels = NULL, right = TRUE){
  
  stopifnot(is.factor(strata))
  
  stopifnot(length(probs) == nlevels(strata))
  
  if(!is.null(cutoff)){
    stopifnot(length(cutoff) == nlevels(strata))
  }
  
  strata_levels <- levels(strata)
  
  out <- wrapper_cut_2groups(x, probs = probs[1], cutoff = cutoff[1], labels = labels, right = right) 
  
  all_levels <- levels(out)
  
  out <- factor(rep(NA, length(x)), levels = all_levels)
  
  for(i in seq_along(strata_levels)){
    # i = 1
    
    indx_sub <- which(strata %in% strata_levels[i])
    
    out[indx_sub] <- wrapper_cut_2groups(x[indx_sub], probs = probs[i], cutoff = cutoff[i], labels = labels, right = right) 
    
  }
  
  return(out)
  
}









#' Internal function used in bkable to highlight the rows 
#' 
#' @keywords internal
indicate_blocks <- function(d, block_vars, return = "block"){
  
  stopifnot(length(return) == 1)
  stopifnot(return %in% c("block", "line", "empty"))
  
  
  all_data <- apply(d[, block_vars, drop = FALSE], 1, paste, collapse = ".")
  
  all_rle <- c(0, cumsum(rle(all_data)$lengths))
  
  
  if(return == "block"){
    
    if(length(all_rle) > 2){
      
      max_rle_indx <- ifelse(length(all_rle) %% 2 == 0, length(all_rle), length(all_rle) - 1)
      
      out <- unlist(lapply(seq(1, max_rle_indx, by = 2), function(i){
        seq(all_rle[i] + 1, all_rle[i + 1], by = 1)
      }))
      
    }else{
      out <- NULL
    }
    
    
  }else if(return == "line"){
    
    out <- all_rle[-1]
    
    
  }else if(return == "empty"){
    
    ## Indicate first lines that are unique
    out <- c(1, all_rle[-1] + 1)
    out <- out[-length(out)]
    
    ## But make empty all besides them
    
    out <- setdiff(1:nrow(d), out)
    
    
  }
  
  
  return(out)
  
}






#' Format header for kable
#' 
#' @param all_colnames All column names 
#' @param header_colnames Column names where the header should be placed.
#' @param header_name Name of the header.
#' 
#' @examples 
#' 
#' \dontrun{
#' all_colnames <- c("Covariate", "Subgroup", "A", "B", "C", "OR", "P-value")
#' header_colnames <- c("A", "B", "C")
#' header_name <- "Gene A"
#' 
#' format_header(all_colnames, header_colnames, header_name)
#' 
#' 
#' all_colnames <- c("A", "B", "C", "OR", "P-value")
#' header_colnames <- c("A", "B", "C")
#' header_name <- "Gene A"
#' 
#' format_header(all_colnames, header_colnames, header_name)
#' }
#' @keywords internal
format_header <- function(all_colnames, header_colnames, header_name){
  
  
  header_indx <- which(all_colnames %in% header_colnames)
  num_mid_cols <- length(header_indx)
  stopifnot(num_mid_cols > 0)
  
  
  if(header_indx[1] > 1){
    
    num_start_cols <- header_indx[1] - 1
    
    if(header_indx[num_mid_cols] < length(all_colnames)){
      
      num_end_cols <- length(all_colnames) - header_indx[num_mid_cols]
      
      header <- c(num_start_cols, num_mid_cols, num_end_cols)
      header <- as.integer(header)
      names(header) <- c(" ", header_name, " ") 
      
    }else{
      
      header <- c(num_start_cols, num_mid_cols)
      header <- as.integer(header)
      names(header) <- c(" ", header_name)
      
    }
    
  }else{
    
    
    if(header_indx[num_mid_cols] < length(all_colnames)){
      
      num_end_cols <- length(all_colnames) - header_indx[num_mid_cols]
      
      header <- c(num_mid_cols, num_end_cols)
      header <- as.integer(header)
      names(header) <- c(header_name, " ") 
      
    }else{
      
      header <- c(num_mid_cols)
      header <- as.integer(header)
      names(header) <- c(header_name)
      
    }
    
    
  }
  
  stopifnot(sum(header) == length(all_colnames))
  
  header
  
  
}






#' Format p-values
#' 
#' @param x Vector of p-values to be formatted.
#' @param digits Number of digits after decimal to display.
#' @param asterisk Logical, whether to indicate significance levels with asterisks. Encoding: `***` p-value < 0.001, `**` p-value < 0.01, `*` p-value < 0.05, `.` p-value < 0.1.
#' @param non_empty Vector defining which values should be displayed despite being NAs.
#' @keywords internal 
format_pvalues <- function(x, digits = 4, asterisk = TRUE, non_empty = NULL){
  
  
  if(!is.null(non_empty)){
    if(is.logical(non_empty)){
      stopifnot(length(non_empty) == length(x))
    }else{
      non_empty_logical <- rep(FALSE, length(x))
      non_empty_logical[non_empty] <- TRUE
      non_empty <- non_empty_logical
      stopifnot(length(non_empty) == length(x))
    }
  }
  
  
  # digits = 4
  # asterisk <- TRUE
  # x <- c(0.2, 0.05, 0.034534, 1.366332e-05, 1.366332e-04, NA)
  
  
  if(sum(is.na(x)) == length(x) && is.null(non_empty)){
    output <- rep("", length(x))
    return(output)
  }else if(sum(is.na(x)) == length(x) && !is.null(non_empty)){
    output <- rep("", length(x))
    output[non_empty] <- "NA"
    return(output)
  }
  
  min_pval <- 1/10^digits
  
  output <- formatC(x, format = "f", digits = digits, drop0trailing = FALSE)
  output[x < min_pval] <- paste0("<", formatC(min_pval, format = "f", digits = digits))
  output[is.na(x)] <- "NA"
  
  if(is.null(non_empty)){
    output[output == "NA"] <- ""
  }else{
    output[output == "NA" & !non_empty] <- ""
  }
  
  
  if(asterisk){
    
    pval_asterisk <- ifelse(x < 0.001, " ***", ifelse(x < 0.01, " **", ifelse(x < 0.05, " *", ifelse(x < 0.1, " .", ""))))
    
    pval_asterisk[is.na(pval_asterisk)] <- ""
    
    output <- paste0(output, pval_asterisk)
    
  }
  
  return(output)
  
}



#' Format p-values using scientific format
#' 
#' @param x Vector of p-values to be formatted.
#' @param digits Number of digits after decimial to display.
#' @param asterisk Logical, whether to indicate significance levels with asterisks. Encoding: `***` p-value < 0.001, `**` p-value < 0.01, `*` p-value < 0.05, `.` p-value < 0.1.
#' @keywords internal 
format_pvalues2 <- function(x, digits = 4, asterisk = TRUE){
  
  # digits = 4
  # asterisk <- TRUE
  # x <- c(0.2, 0.05, 0.034534, 0.007, 1.366332e-05, 1.366332e-04, NA, 7.174163e-16, 1.501826e-06, 6.642127e-10)
  
  
  if(sum(is.na(x)) == length(x)){
    return(rep("", length(x)))
  }
  
  
  min_pval <- 1/10^digits
  
  output_format_non_scientific <- formatC(x, format = "f", digits = digits, drop0trailing = FALSE)
  
  output_format_scientific <- paste0("<", formatC(10 ^ -floor(-log10(x)), format = "e", digits = 0))
  
  output_format_scientific
  
  
  output <- ifelse(x < min_pval, output_format_scientific, output_format_non_scientific)
  
  output[is.na(x)] <- ""
  
  
  
  if(asterisk){
    
    pval_asterisk <- ifelse(x < 0.001, " ***", ifelse(x < 0.01, " **", ifelse(x < 0.05, " *", ifelse(x < 0.1, " .", ""))))
    
    pval_asterisk[is.na(pval_asterisk)] <- ""
    
    output <- paste0(output, pval_asterisk)
    
  }
  
  
  return(output)
  
}







#' Format Odds Ratios
#' 
#' @param x Vector with odds ratios.
#' @param digits Number of decimal places.
#' @param non_empty Vector defining which values should be displayed despite being NAs.
#' @keywords internal 
format_or <- function(x, digits = 2, non_empty = NULL){
  
  max_val <- 100
  
  if(!is.null(non_empty)){
    if(is.logical(non_empty)){
      stopifnot(length(non_empty) == length(x))
    }else{
      non_empty_logical <- rep(FALSE, length(x))
      non_empty_logical[non_empty] <- TRUE
      non_empty <- non_empty_logical
      stopifnot(length(non_empty) == length(x))
    }
  }
  
  
  if(sum(is.na(x)) == length(x) && is.null(non_empty)){
    output <- rep("", length(x))
    return(output)
  }else if(sum(is.na(x)) == length(x) && !is.null(non_empty)){
    output <- rep("", length(x))
    output[non_empty] <- "NA"
    return(output)
  }
  
  min_val <- 1/10^digits
  
  output <- formatC(x, format = "f", digits = digits, drop0trailing = FALSE)
  output[x < min_val] <- paste0("<", formatC(min_val, format = "f", digits = digits))
  output[x > max_val] <- paste0(">", formatC(max_val, format = "f", digits = digits))
  output[x %in% 0] <- "0"
  output[is.na(x)] <- "NA"
  
  if(is.null(non_empty)){
    output[output == "NA"] <- ""
  }else{
    output[output == "NA" & !non_empty] <- ""
  }
  
  
  return(output)
  
}


#' Format difference 
#' 
#' @param x Vector with differences.
#' @param digits Number of decimal places.
#' @param non_empty Vector defining which values should be displayed despite being NAs.
#' @keywords internal
format_difference <- function(x, digits = 2, non_empty = NULL){
  
  
  if(!is.null(non_empty)){
    if(is.logical(non_empty)){
      stopifnot(length(non_empty) == length(x))
    }else{
      non_empty_logical <- rep(FALSE, length(x))
      non_empty_logical[non_empty] <- TRUE
      non_empty <- non_empty_logical
      stopifnot(length(non_empty) == length(x))
    }
  }
  
  if(sum(is.na(x)) == length(x) && is.null(non_empty)){
    output <- rep("", length(x))
    return(output)
  }else if(sum(is.na(x)) == length(x) && !is.null(non_empty)){
    output <- rep("", length(x))
    output[non_empty] <- "NA"
    return(output)
  }
  
  min_val <- 1/10^digits
  
  output <- formatC(x, format = "f", digits = digits, drop0trailing = FALSE)
  output[is.na(x)] <- "NA"
  
  if(is.null(non_empty)){
    output[output == "NA"] <- ""
  }else{
    output[output == "NA" & !non_empty] <- ""
  }
  
  return(output)
  
}



#' Format CIs (confidence intervals)
#' 
#' @param CI_lower Vector with lower CIs.
#' @param CI_upper Vector with upper CIs.
#' @param digits Number of decimal places.
#' @param non_empty Vector defining which values should be displayed despite being NAs.
#' @keywords internal
format_CIs <- function(CI_lower, CI_upper, digits = 2, non_empty = NULL, parentheses = FALSE){
  
  stopifnot(length(CI_lower) == length(CI_upper))
  
  if(!is.null(non_empty)){
    if(is.logical(non_empty)){
      stopifnot(length(non_empty) == length(CI_lower))
    }else{
      non_empty_logical <- rep(FALSE, length(CI_lower))
      non_empty_logical[non_empty] <- TRUE
      non_empty <- non_empty_logical
      stopifnot(length(non_empty) == length(CI_lower))
    }
  }
  
  if(sum(is.na(CI_lower)) == length(CI_lower) && sum(is.na(CI_upper)) == length(CI_upper) && is.null(non_empty)){
    output <- rep("", length(CI_lower))
    return(output)
  }else if(sum(is.na(CI_lower)) == length(CI_lower) && sum(is.na(CI_upper)) == length(CI_upper) && !is.null(non_empty)){
    output <- rep("", length(CI_lower))
    output[non_empty] <- "NA"
    return(output)
  }
  
  
  if(parentheses){
    output <- paste0("(", formatC(CI_lower, format = "f", digits = digits, drop0trailing = FALSE), "% - ", formatC(CI_upper, format = "f", digits = digits, drop0trailing = FALSE), "%)")
  }else{
    output <- paste0("(", formatC(CI_lower, format = "f", digits = digits, drop0trailing = FALSE), " - ", formatC(CI_upper, format = "f", digits = digits, drop0trailing = FALSE), ")")
  }
  
  
  output[is.na(CI_lower) & is.na(CI_upper)] <- "NA"
  
  if(is.null(non_empty)){
    output[output == "NA"] <- ""
  }else{
    output[output == "NA" & !non_empty] <- ""
  }
  
  return(output)
  
}


#' Format CIs (confidence intervals)
#' 
#' @param x Data frame.
#' @param digits Number of decimal places.
#' @param colnames New colnames.
#' @param non_empty Vector defining which values should be displayed despite being NAs.
#' @keywords internal
format_CIs_df <- function(x, digits = 2, colnames = NULL, non_empty = NULL, parentheses = FALSE){
  
  output <- data.frame(format_CIs(x[, 1], x[, 2], digits = digits, non_empty = non_empty, parentheses = parentheses), stringsAsFactors = FALSE)
  colnames(output) <- colnames
  
  return(output)
  
}




#' Format versus
#' 
#' @param level Vector with levels.
#' @param reference Vector with references.
#' @keywords internal
format_vs <- function(level, reference){
  
  output <- paste0(level, " vs ", reference)
  
  output[level == "" & reference == ""] <- ""
  output[level == 0 & reference == 0] <- ""
  output[is.na(level) & is.na(reference)] <- ""
  
  
  return(output)
  
}



#' Format proportions
#' 
#' @param x Vector with proportions.
#' @param digits Number of decimal places when rounding proportions.
#' @keywords internal
format_props <- function(x, digits = 2, non_empty = NULL){
  
  
  if(!is.null(non_empty)){
    if(is.logical(non_empty)){
      stopifnot(length(non_empty) == length(x))
    }else{
      non_empty_logical <- rep(FALSE, length(x))
      non_empty_logical[non_empty] <- TRUE
      non_empty <- non_empty_logical
      stopifnot(length(non_empty) == length(x))
    }
  }
  
  
  if(sum(is.na(x)) == length(x) && is.null(non_empty)){
    output <- rep("", length(x))
    return(output)
  }else if(sum(is.na(x)) == length(x) && !is.null(non_empty)){
    output <- rep("", length(x))
    output[non_empty] <- "NA"
    return(output)
  }
  
  ### With parentheses 
  
  # output <- paste0(" (", formatC(as.numeric(x), format = "f", digits = digits, drop0trailing = FALSE), "%)")
  
  ### Without parentheses 
  
  output <- paste0(formatC(as.numeric(x), format = "f", digits = digits, drop0trailing = FALSE), "%")
  output[is.na(x)] <- "NA"
  
  
  if(is.null(non_empty)){
    output[output == "NA"] <- ""
  }else{
    output[output == "NA" & !non_empty] <- ""
  }
  
  
  return(output)
  
  
}


#' Paste counts and proportions corresponding to one subgroup
#' 
#' @param counts Vector with counts.
#' @param props Vector with proportions.
#' @param digits Number of decimal places when rounding proportions.
#' @keywords internal
format_counts_and_props <- function(counts, props, digits = 2){
  
  
  out <- paste0(ifelse(is.na(counts), "", counts), ifelse(is.na(props), "", paste0(" (", formatC(as.numeric(props), format = "f", digits = digits, drop0trailing = FALSE), "%)")))
  
  # Remove white spaces from the beginning and the end of a string
  
  out <- stringr::str_trim(out, side = "both")
  
  out
  
  
  
}




#' Paste counts and proportions corresponding to one subgroup
#' 
#' @param counts Data frame with counts.
#' @param props Data frame with proportions.
#' @param digits Number of decimal places when rounding proportions.
#' @keywords internal
format_counts_and_props_df <- function(counts, props, digits = 2, prefix_counts = "counts_"){
  
  ### Match pattern at the beginning
  pattern <- paste0("^", prefix_counts)
  
  output_names <- gsub(pattern, "", colnames(counts))
  
  stopifnot(all(dim(counts) == dim(props)))
  
  
  output <- lapply(1:nrow(counts), function(i){
    # i = 1
    
    out <- format_counts_and_props(counts = counts[i, ], props = props[i, ], digits = digits)
    
    return(out)
    
  })
  
  output <- data.frame(do.call("rbind", output), stringsAsFactors = FALSE)
  
  colnames(output) <- output_names
  
  return(output)
  
}





#' Format summary statistics such as N, mean, median, min, max
#' 
#' @param summ Vector with values to format.
#' @param digits Vector with digits used in formatC.
#' 
#' @examples 
#' 
#' \dontrun{
#' summ <- c(10, 1000000, 1e6, 23.6442)
#' digits <- c(0, 0, 0, 2)
#' 
#' format_summ(summ, digits)
#' }
#' 
#' @keywords internal
format_summ <- function(summ, digits = 2){
  
  summ <- as.numeric(summ)
  
  if(length(digits) == 1){
    digits <- rep(digits, times = length(summ))
  }else{
    stopifnot(length(digits) == length(summ))
  }
  
  out <- sapply(seq_along(summ), function(i){
    
    out <- ifelse(is.na(summ[i]), "", formatC(summ[i], format = "f", digits = digits[i], drop0trailing = FALSE))
    
  })
  
  
  return(out)
  
}




#' Format summary statistics such as N, mean, median, min, max
#' 
#' @param summ Data frame.
#' @param per Whether to lapply per row or per column.
#' @param digits Vector with digits used in formatC.
#' @keywords internal
format_summ_df <- function(summ, per = "row", digits = 2){
  
  stopifnot(is.data.frame(summ) || is.matrix(summ))
  
  stopifnot(per %in% c("row", "col"))
  
  
  if(per == "row"){
    
    output <- lapply(1:nrow(summ), function(i){
      # i = 1
      
      out <- format_summ(summ[i, ], digits = digits)
      
    })
    
    output <- data.frame(do.call("rbind", output), stringsAsFactors = FALSE)
    
  }else{
    
    output <- lapply(1:ncol(summ), function(i){
      # i = 1
      
      out <- format_summ(summ[, i], digits = digits)
      
    })
    
    output <- data.frame(do.call("cbind", output), stringsAsFactors = FALSE)
    
  }
  
  colnames(output) <- colnames(summ)
  
  return(output)
  
}



#' Create variable names
#' 
#' Make sure that variable names exists for all the variables in the data frame. Creates from scratch or adds missing variable names for variables in data.
#' 
#' @param data Data frame or vector.
#' @param variable_names Named vector of variable names corresponding to variables in data. This vector does not have to contain names for all the variables in data. If names for some variables are missing, they will be created. If NULL, variable names are created by subtracting underscore from the column names of data.
#' @return Named vector of (optionally unique) variable names for all variables from data.
#' @export
format_variable_names <- function(data, variable_names = NULL, unique = FALSE){
  
  if(is.data.frame(data)){
    x <- colnames(data)
  }else{
    x <- data
  }
  
  new_variable_names <- gsub("_", " ", x)
  names(new_variable_names) <- x
  
  
  if(!is.null(variable_names)){
    
    ## If variable_names is provided, it has to be a named vector
    stopifnot(!is.null(names(variable_names)))
    
    ## If there are multiple names corresponding to one variable, we keep the first one 
    if(sum(duplicated(names(variable_names))) > 0){
      warning("\nSome variables have multiple names assigned. The first one will be kept. Please double check if this is the name that you want to use.\n")
    }
    
    variable_names <- variable_names[!duplicated(names(variable_names))]
    
    mm <- match(names(new_variable_names), names(variable_names))
    new_variable_names[!is.na(mm)] <- variable_names[stats::na.omit(mm)]
    
  }
  
  
  if(unique){
    
    ## There cannot be duplicated names. If so, fix it.
    
    if(sum(duplicated(new_variable_names)) > 0){
      
      dupl_names <- unique(new_variable_names[duplicated(new_variable_names)])
      
      fixed_names <- lapply(seq_along(dupl_names), function(i){
        # i = 1
        
        dupl_indx <- which(new_variable_names == dupl_names[i])
        
        new_names <- paste(dupl_names[i], 1:length(dupl_indx))
        
        out <- data.frame(dupl_indx = dupl_indx, new_names = new_names, stringsAsFactors = FALSE)
        
        
      })
      
      fixed_names <- plyr::rbind.fill(fixed_names)
      
      new_variable_names[fixed_names[, "dupl_indx"]] <- fixed_names[, "new_names"]
      
    }
    
  }
  
  
  
  return(new_variable_names)
  
  
}


#' Format or create shapes for a vector with categorical values
#' 
#' @param x Vector of categorical values for which we want to specify shapes.
#' @param shapes Vector of shapes longer or equal the number of unique levels of x. Can be named or non-named. If NULL, shapes are generated.
#' @return Named vector of shapes for all unique values of x.
#' 
#' @export
format_shapes <- function(x, shapes = NULL, allow_duplicated = TRUE){
  
  
  x <- x[!is.na(x)]
  
  if(!is.factor(x)){
    x <- factor(x, levels = unique(x))
  }
  
  levels_x <- levels(x)
  
  
  if(is.null(shapes)){
    
    out <- c(16, 17, 15, 18, 0:14)[seq_along(levels_x)]
    names(out) <- levels_x
    
  }else{
    
    stopifnot(length(shapes) >= length(levels_x))
    
    if(is.null(names(shapes))){
      out <- shapes[seq_along(levels_x)]
      names(out) <- levels_x
    }else{
      stopifnot(all(levels_x %in% names(shapes)))
      out <- shapes[levels_x]
    }
    
    
    if(!allow_duplicated){
      stopifnot(sum(duplicated(out)) == 0)
    }
    
    
  }
  
  
  return(out)
  
  
}



#' Format or create colors for a vector with categorical values
#' 
#' Make sure that unique named colors are created for each value.
#' 
#' @param x Vector of categorical values for which we want to specify colors.
#' @param colors Vector of colors longer or equal the number of unique levels of x. Can be named or non-named. If NULL, colors are generated.
#' @param palette Vector of at least two colors used to create a color palette with 'colorRampPalette' or name of a RColorBrewer palette e.g. "Oranges", "Blues", "Spectral", "RdYlBu". Other possible values: "random", "d3_40_light_first", "d3_20", "d3_10", "paired", "ggplot", "Oranges2", "Blues2".
#' @return Named vector of unique colors for all unique values of x.
#' 
#' @examples 
#' 
#' x <- c("low", "high")
#' 
#' colors <- c("high" = "red", "low" = "grey")
#' palette <- NULL
#' allow_duplicated <- FALSE
#' 
#' 
#' format_colors_cat(x, colors = colors, palette = palette, allow_duplicated = allow_duplicated)
#' 
#' 
#' x <- c("<1", "<2", "<3", "<4")
#'
#' colors <- NULL
#' palette <- "RdYlBu"
#' allow_duplicated <- FALSE
#' 
#' 
#' out <- format_colors_cat(x, colors = colors, palette = palette, allow_duplicated = allow_duplicated)
#' 
#' barplot(rep(1, length(out)), col = out)
#' 
#' 
#' @export
format_colors_cat <- function(x, colors = NULL, palette = NULL, rev = FALSE, allow_duplicated = TRUE){
  
  
  if(is.null(palette)){
    palette <- "d3_40_light_first"
  }
  
  x <- x[!is.na(x)]
  
  if(!is.factor(x)){
    x <- factor(x, levels = unique(x))
  }
  
  levels_x <- levels(x)
  
  
  
  if(is.null(colors)){
    
    
    if(length(palette) == 1){
      
      
      if(palette == "d3_40"){
        
        ### d3_20 + Add another 20 colors
        
        colors_default <- c("#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5",
          "#CD5B45", "#FF7256", "#CD950C", "#FFB90F", "#66CDAA", "#7FFFD4", "#3A5FCD", "#1E90FF", "#CD00CD", "#FF00FF", "#698B22", "#C0FF3E", "#6C7B8B", "#B9D3EE", "#CDCD00", "#FFFF00", "#008B45", "#00FF7F", "#CDB5CD", "#FFE1FF")
        
        
        # barplot(rep(1, length(colors_default)), col = colors_default)
        
        stopifnot(length(levels_x) <= 40)
        
        out <- colors_default[1:length(levels_x)]
        names(out) <- levels_x
        
        
      }else if(palette == "d3_40_light_first"){
        
        ### Mix d3 20 - light color first with paired colors from brewer.pal + Add another 20 colors
        
        colors_default <- c("#aec7e8", "#1F78B4", "#FDBF6F", "#FF7F00", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#c5b0d5", "#9467bd", "#c49c94", "#8c564b", "#f7b6d2", "#e377c2", "#c7c7c7", "#7f7f7f", "#dbdb8d", "#bcbd22", "#9edae5", "#17becf",
          "#FF7256", "#CD5B45", "#FFB90F", "#CD950C", "#7FFFD4", "#66CDAA", "#1E90FF", "#3A5FCD", "#FF00FF", "#CD00CD", "#C0FF3E", "#698B22", "#B9D3EE", "#6C7B8B", "#FFFF00", "#CDCD00", "#00FF7F", "#008B45", "#FFE1FF", "#CDB5CD")
        
        
        # barplot(rep(1, length(colors_default)), col = colors_default)
        
        stopifnot(length(levels_x) <= 40)
        
        out <- colors_default[1:length(levels_x)]
        names(out) <- levels_x
        
        
      }else if(palette == "d3_20"){
        
        colors_default <- c("#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5")
        
        
        # barplot(rep(1, length(colors_default)), col = colors_default)
        
        stopifnot(length(levels_x) <= 20)
        
        out <- colors_default[1:length(levels_x)]
        names(out) <- levels_x
        
        
      }else if(palette == "d3_10"){
        
        
        colors_default <-c('#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf')
        
        
        # barplot(rep(1, length(colors_default)), col = colors_default)
        
        stopifnot(length(levels_x) <= 10)
        
        out <- colors_default[1:length(levels_x)]
        names(out) <- levels_x
        
        
      }else if(palette %in% "ggplot"){
        
        gg_color_hue <- function(n) {
          hues = seq(15, 375, length = n+1)
          hcl(h = hues, l = 65, c = 100)[1:n]
        }
        
        out <- gg_color_hue(length(levels_x))
        
        
      }else if(palette %in% "random"){
        
        # colors_all <- grDevices::colors(distinct = TRUE)
        # cat(paste0('"', paste(colors_all, collapse='", "'), '"'))
        
        
        c("white", "aliceblue", "antiquewhite", "antiquewhite1", "antiquewhite2", "antiquewhite3", "antiquewhite4", "aquamarine", "aquamarine2", "aquamarine3", "aquamarine4", "azure", "azure2", "azure3", "azure4", "beige", "bisque", "bisque2", "bisque3", "bisque4", "black", "blanchedalmond", "blue", "blue2", "blue3", "blue4", "blueviolet", "brown", "brown1", "brown2", "brown3", "brown4", "burlywood", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "cadetblue", "cadetblue1", "cadetblue2", "cadetblue3", "cadetblue4", "chartreuse", "chartreuse2", "chartreuse3", "chartreuse4", "chocolate", "chocolate1", "chocolate2", "chocolate3", "chocolate4", "coral", "coral1", "coral2", "coral3", "coral4", "cornflowerblue", "cornsilk", "cornsilk2", "cornsilk3", "cornsilk4", "cyan", "cyan2", "cyan3", "cyan4", "darkgoldenrod", "darkgoldenrod1", "darkgoldenrod2", "darkgoldenrod3", "darkgoldenrod4", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkolivegreen1", "darkolivegreen2", "darkolivegreen3", "darkolivegreen4", "darkorange", "darkorange1", "darkorange2", "darkorange3", "darkorange4", "darkorchid", "darkorchid1", "darkorchid2", "darkorchid3", "darkorchid4", "darkred", "darksalmon", "darkseagreen", "darkseagreen1", "darkseagreen2", "darkseagreen3", "darkseagreen4", "darkslateblue", "darkslategray", "darkslategray1", "darkslategray2", "darkslategray3", "darkslategray4", "darkturquoise", "darkviolet", "deeppink", "deeppink2", "deeppink3", "deeppink4", "deepskyblue", "deepskyblue2", "deepskyblue3", "deepskyblue4", "dimgray", "dodgerblue", "dodgerblue2", "dodgerblue3", "dodgerblue4", "firebrick", "firebrick1", "firebrick2", "firebrick3", "firebrick4", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "gold2", "gold3", "gold4", "goldenrod", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4", "gray", "gray1", "gray2", "gray3", "gray4", "gray5", "gray6", "gray7", "gray8", "gray9", "gray10", "gray11", "gray12", "gray13", "gray14", "gray15", "gray16", "gray17", "gray18", "gray19", "gray20", "gray21", "gray22", "gray23", "gray24", "gray25", "gray26", "gray27", "gray28", "gray29", "gray30", "gray31", "gray32", "gray33", "gray34", "gray35", "gray36", "gray37", "gray38", "gray39", "gray40", "gray42", "gray43", "gray44", "gray45", "gray46", "gray47", "gray48", "gray49", "gray50", "gray51", "gray52", "gray53", "gray54", "gray55", "gray56", "gray57", "gray58", "gray59", "gray60", "gray61", "gray62", "gray63", "gray64", "gray65", "gray66", "gray67", "gray68", "gray69", "gray70", "gray71", "gray72", "gray73", "gray74", "gray75", "gray76", "gray77", "gray78", "gray79", "gray80", "gray81", "gray82", "gray83", "gray84", "gray85", "gray86", "gray87", "gray88", "gray89", "gray90", "gray91", "gray92", "gray93", "gray94", "gray95", "gray96", "gray97", "gray98", "gray99", "green", "green2", "green3", "green4", "greenyellow", "honeydew", "honeydew2", "honeydew3", "honeydew4", "hotpink", "hotpink1", "hotpink2", "hotpink3", "hotpink4", "indianred", "indianred1", "indianred2", "indianred3", "indianred4", "ivory", "ivory2", "ivory3", "ivory4", "khaki", "khaki1", "khaki2", "khaki3", "khaki4", "lavender", "lavenderblush", "lavenderblush2", "lavenderblush3", "lavenderblush4", "lawngreen", "lemonchiffon", "lemonchiffon2", "lemonchiffon3", "lemonchiffon4", "lightblue", "lightblue1", "lightblue2", "lightblue3", "lightblue4", "lightcoral", "lightcyan", "lightcyan2", "lightcyan3", "lightcyan4", "lightgoldenrod", "lightgoldenrod1", "lightgoldenrod2", "lightgoldenrod3", "lightgoldenrod4", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightpink1", "lightpink2", "lightpink3", "lightpink4", "lightsalmon", "lightsalmon2", "lightsalmon3", "lightsalmon4", "lightseagreen", "lightskyblue", "lightskyblue1", "lightskyblue2", "lightskyblue3", "lightskyblue4", "lightslateblue", "lightslategray", "lightsteelblue", "lightsteelblue1", "lightsteelblue2", "lightsteelblue3", "lightsteelblue4", "lightyellow", "lightyellow2", "lightyellow3", "lightyellow4", "limegreen", "linen", "magenta", "magenta2", "magenta3", "maroon", "maroon1", "maroon2", "maroon3", "maroon4", "mediumorchid", "mediumorchid1", "mediumorchid2", "mediumorchid3", "mediumorchid4", "mediumpurple", "mediumpurple1", "mediumpurple2", "mediumpurple3", "mediumpurple4", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "mistyrose2", "mistyrose3", "mistyrose4", "moccasin", "navajowhite", "navajowhite2", "navajowhite3", "navajowhite4", "navy", "oldlace", "olivedrab", "olivedrab1", "olivedrab2", "olivedrab3", "olivedrab4", "orange", "orange2", "orange3", "orange4", "orangered", "orangered2", "orangered3", "orangered4", "orchid", "orchid1", "orchid2", "orchid3", "orchid4", "palegoldenrod", "palegreen", "palegreen1", "palegreen3", "palegreen4", "paleturquoise", "paleturquoise1", "paleturquoise2", "paleturquoise3", "paleturquoise4", "palevioletred", "palevioletred1", "palevioletred2", "palevioletred3", "palevioletred4", "papayawhip", "peachpuff", "peachpuff2", "peachpuff3", "peachpuff4", "peru", "pink", "pink1", "pink2", "pink3", "pink4", "plum", "plum1", "plum2", "plum3", "plum4", "powderblue", "purple", "purple1", "purple2", "purple3", "purple4", "red", "red2", "red3", "rosybrown", "rosybrown1", "rosybrown2", "rosybrown3", "rosybrown4", "royalblue", "royalblue1", "royalblue2", "royalblue3", "royalblue4", "salmon", "salmon1", "salmon2", "salmon3", "salmon4", "sandybrown", "seagreen", "seagreen1", "seagreen2", "seagreen3", "seashell", "seashell2", "seashell3", "seashell4", "sienna", "sienna1", "sienna2", "sienna3", "sienna4", "skyblue", "skyblue1", "skyblue2", "skyblue3", "skyblue4", "slateblue", "slateblue1", "slateblue2", "slateblue3", "slateblue4", "slategray", "slategray1", "slategray2", "slategray3", "slategray4", "snow", "snow2", "snow3", "snow4", "springgreen", "springgreen2", "springgreen3", "springgreen4", "steelblue", "steelblue1", "steelblue2", "steelblue3", "steelblue4", "tan", "tan1", "tan2", "tan4", "thistle", "thistle1", "thistle2", "thistle3", "thistle4", "tomato", "tomato2", "tomato3", "tomato4", "turquoise", "turquoise1", "turquoise2", "turquoise3", "turquoise4", "violet", "violetred", "violetred1", "violetred2", "violetred3", "violetred4", "wheat", "wheat1", "wheat2", "wheat3", "wheat4", "yellow", "yellow2", "yellow3", "yellow4")
        
        
        colors_default <- c(
          "antiquewhite", "antiquewhite2", "antiquewhite3", "antiquewhite4", 
          "aquamarine", "aquamarine2", "aquamarine3", "aquamarine4", 
          "azure", "azure2", "azure3", "azure4", 
          "bisque", "bisque2", "bisque3", "bisque4", 
          "blue", "blue2", "blue3", "blue4", 
          "brown", "brown2", "brown3", "brown4", 
          "burlywood", "burlywood2", "burlywood3", "burlywood4", 
          "cadetblue", "cadetblue2", "cadetblue3", "cadetblue4", 
          "chartreuse", "chartreuse2", "chartreuse3", "chartreuse4", 
          "chocolate", "chocolate2", "chocolate3", "chocolate4", 
          "coral", "coral2", "coral3", "coral4", 
          "cornflowerblue", 
          "cornsilk", "cornsilk2", "cornsilk3", "cornsilk4", 
          "cyan", "cyan2", "cyan3", "cyan4", 
          "darkgoldenrod", "darkgoldenrod2", "darkgoldenrod3", "darkgoldenrod4", 
          "darkgray", 
          "darkgreen", 
          "darkkhaki", 
          "darkmagenta", 
          "darkolivegreen", "darkolivegreen2", "darkolivegreen3", "darkolivegreen4", 
          "darkorange", "darkorange2", "darkorange3", "darkorange4", 
          "darkorchid", "darkorchid2", "darkorchid3", "darkorchid4", 
          "darkred", 
          "darksalmon", 
          "darkseagreen", "darkseagreen2", "darkseagreen3", "darkseagreen4", 
          "darkslateblue", 
          "darkslategray", "darkslategray2", "darkslategray3", "darkslategray4",
          "darkturquoise", 
          "darkviolet", 
          "deeppink", "deeppink2", "deeppink3", "deeppink4", 
          "deepskyblue", "deepskyblue2", "deepskyblue3", "deepskyblue4", 
          "dimgray", 
          "dodgerblue", "dodgerblue2", "dodgerblue3", "dodgerblue4", 
          "firebrick", "firebrick2", "firebrick3", "firebrick4", 
          "forestgreen", 
          "gold", "gold2", "gold3", "gold4", 
          "goldenrod", "goldenrod2", "goldenrod3", "goldenrod4", 
          "gray", 
          "green", "green2", "green3", "green4", 
          "greenyellow", 
          "honeydew", "honeydew2", "honeydew3", "honeydew4", 
          "hotpink", "hotpink2", "hotpink3", "hotpink4", 
          "indianred", "indianred2", "indianred3", "indianred4", 
          "ivory", "ivory2", "ivory3", "ivory4", 
          "khaki", "khaki2", "khaki3", "khaki4", 
          "lavender", 
          "lavenderblush", "lavenderblush2", "lavenderblush3", "lavenderblush4", 
          "lawngreen", 
          "lemonchiffon", "lemonchiffon2", "lemonchiffon3", "lemonchiffon4", 
          "lightblue", "lightblue2", "lightblue3", "lightblue4", 
          "lightcoral", 
          "lightcyan", "lightcyan2", "lightcyan3", "lightcyan4", 
          "lightgoldenrod", "lightgoldenrod2", "lightgoldenrod3", "lightgoldenrod4",
          "lightgoldenrodyellow", 
          "lightgray", 
          "lightgreen", 
          "lightpink", "lightpink2", "lightpink3", "lightpink4", 
          "lightsalmon", "lightsalmon2", "lightsalmon3", "lightsalmon4", 
          "lightseagreen", 
          "lightskyblue", "lightskyblue2", "lightskyblue3", "lightskyblue4", 
          "lightslateblue", 
          "lightslategray", 
          "lightsteelblue", "lightsteelblue2", "lightsteelblue3","lightsteelblue4",
          "lightyellow", "lightyellow2", "lightyellow3", "lightyellow4", 
          "limegreen", 
          "linen", 
          "magenta", "magenta2", "magenta3", 
          "maroon", "maroon2", "maroon3", "maroon4", 
          "mediumorchid", "mediumorchid2", "mediumorchid3", "mediumorchid4", 
          "mediumpurple", "mediumpurple2", "mediumpurple3", "mediumpurple4", 
          "mediumseagreen", 
          "mediumslateblue", 
          "mediumspringgreen", 
          "mediumturquoise", 
          "mediumvioletred", 
          "midnightblue", 
          "mintcream", 
          "mistyrose", "mistyrose2", "mistyrose3", "mistyrose4",
          "moccasin", 
          "navajowhite", "navajowhite2", "navajowhite3", "navajowhite4", 
          "navy", 
          "oldlace", 
          "olivedrab", "olivedrab2", "olivedrab3", "olivedrab4", 
          "orange", "orange2", "orange3", "orange4", 
          "orangered", "orangered2", "orangered3", "orangered4", 
          "orchid", "orchid2", "orchid3", "orchid4", 
          "palegoldenrod", 
          "palegreen", "palegreen1", "palegreen3", "palegreen4", 
          "paleturquoise", "paleturquoise2", "paleturquoise3", "paleturquoise4",
          "palevioletred", "palevioletred2", "palevioletred3", "palevioletred4", 
          "papayawhip", 
          "peachpuff", "peachpuff2", "peachpuff3", "peachpuff4", 
          "peru", 
          "pink", "pink2", "pink3", "pink4", 
          "plum", "plum2", "plum3", "plum4",
          "powderblue", 
          "purple", "purple2", "purple3", "purple4", 
          "red", "red2", "red3", 
          "rosybrown", "rosybrown2", "rosybrown3", "rosybrown4", 
          "royalblue", "royalblue2", "royalblue3", "royalblue4", 
          "salmon", "salmon2", "salmon3", "salmon4", 
          "sandybrown", 
          "seagreen", "seagreen1", "seagreen2", "seagreen3", 
          "seashell", "seashell2", "seashell3", "seashell4", 
          "sienna", "sienna1", "sienna2", "sienna3",  
          "skyblue", "skyblue1", "skyblue3", "skyblue4", 
          "slateblue1", "slateblue2", "slateblue3", "slateblue4", 
          "slategray1", "slategray2", "slategray3", "slategray4", 
          "snow", "snow2", "snow3", "snow4", 
          "springgreen", "springgreen2", "springgreen3", "springgreen4", 
          "steelblue1", "steelblue2", "steelblue3", "steelblue4", 
          "tan", "tan1", "tan2", "tan4", 
          "thistle1", "thistle2", "thistle3", "thistle4", 
          "tomato", "tomato2", "tomato3", "tomato4",
          "turquoise1", "turquoise2", "turquoise3", "turquoise4", 
          "violet", 
          "violetred", "violetred2", "violetred3", "violetred4", 
          "wheat1", "wheat2", "wheat3", "wheat4", 
          "yellow", "yellow2", "yellow3", "yellow4"
        )
        
        
        
        # # conversion function
        # rgb2lab <- function(rgb_col) {
        #   rgb_mat <- t(col2rgb(rgb_col)/255)
        #   lab_mat <- convertColor(rgb_mat, from = "sRGB", to = "Lab")
        #   return(lab_mat)
        # }
        # 
        # # applying conversion function
        # colors_default_lab <- rgb2lab(colors_default)
        # 
        # # Compute distance matrix
        # dist_mat <- dist(colors_default_lab)
        # 
        # # Hierarchical clustering
        # colors_cluster <- hclust(dist_mat)
        # 
        # # Ordered colors
        # colors_ordered <- colors_default[colors_cluster$order]
        # 
        # cat(paste0('"', paste(colors_ordered, collapse='", "'), '"'))
        
        
        c("blue3", "blue", "blue2", "magenta3", "magenta", "magenta2", "purple3", "darkorchid", "darkorchid3", "darkorchid2", "darkviolet", "purple", "purple2", "violetred2", "deeppink3", "violetred3", "deeppink", "deeppink2", "maroon2", "mediumvioletred", "maroon3", "violetred", "hotpink4", "palevioletred4", "maroon", "maroon4", "deeppink4", "violetred4", "plum2", "plum", "plum3", "hotpink", "hotpink2", "palevioletred2", "hotpink3", "palevioletred", "palevioletred3", "dodgerblue4", "mediumpurple4", "royalblue4", "darkslateblue", "slateblue4", "dodgerblue", "dodgerblue2", "cornflowerblue", "dodgerblue3", "lightslateblue", "slateblue1", "mediumslateblue", "slateblue2", "mediumpurple2", "mediumpurple", "mediumpurple3", "slateblue3", "royalblue3", "royalblue", "royalblue2", "midnightblue", "blue4", "navy", "orchid2", "violet", "orchid", "orchid3", "mediumorchid2", "mediumorchid", "mediumorchid3", "mediumorchid4", "orchid4", "darkmagenta", "darkorchid4", "purple4", "orangered", "orangered2", "red", "red2", "orangered3", "red3", "brown3", "firebrick3", "brown2", "firebrick2", "sienna3", "coral2", "coral3", "tomato3", "tomato", "tomato2", "sienna2", "coral", "sienna1", "darkgoldenrod", "orange3", "gold3", "darkgoldenrod2", "goldenrod2", "goldenrod", "darkgoldenrod3", "goldenrod3", "darkorange", "orange", "orange2", "peru", "sandybrown", "tan1", "tan2", "darkorange3", "chocolate", "chocolate3", "chocolate2", "darkorange2", "tan4", "lightsalmon4", "salmon4", "orange4", "darkgoldenrod4", "goldenrod4", "sienna", "chocolate4", "darkorange4", "lightcoral", "indianred2", "indianred", "indianred3", "lightsalmon3", "salmon3", "lightsalmon", "darksalmon", "lightsalmon2", "salmon", "salmon2", "brown", "firebrick", "darkred", "orangered4", "brown4", "firebrick4", "indianred4", "coral4", "tomato4", "steelblue1", "steelblue2", "deepskyblue", "deepskyblue2", "skyblue3", "deepskyblue3", "steelblue3", "paleturquoise3", "cadetblue3", "darkslategray3", "paleturquoise", "paleturquoise2", "cadetblue2", "darkslategray2", "lightskyblue", "skyblue1", "lightskyblue2", "skyblue", "lightsteelblue3", "slategray3", "lightblue3", "lightskyblue3", "powderblue", "lightblue", "lightblue2", "slategray1", "lightsteelblue", "lightsteelblue2", "slategray2", "darkslategray", "skyblue4", "deepskyblue4", "steelblue4", "lightblue4", "lightslategray", "lightskyblue4", "lightsteelblue4", "slategray4", "dimgray", "honeydew4", "ivory4", "azure4", "lightcyan4", "lavenderblush4", "seashell4", "snow4", "antiquewhite4", "mistyrose4", "rosybrown4", "lightpink4", "pink4", "plum4", "thistle4", "aquamarine4", "darkseagreen4", "cyan4", "turquoise4", "cadetblue", "paleturquoise4", "cadetblue4", "darkslategray4", "lemonchiffon4", "cornsilk4", "lightyellow4", "burlywood4", "bisque4", "peachpuff4", "navajowhite4", "wheat4", "darkolivegreen", "khaki4", "lightgoldenrod4", "turquoise1", "turquoise2", "cyan", "cyan2", "lightseagreen", "mediumturquoise", "turquoise3", "cyan3", "darkturquoise", "darkseagreen2", "darkseagreen", "darkseagreen3", "palegreen3", "mediumseagreen", "seagreen3", "aquamarine3", "aquamarine", "aquamarine2", "darkkhaki", "khaki3", "lightgoldenrod3", "palegoldenrod", "lightgoldenrod", "lightgoldenrod2", "khaki", "khaki2", "burlywood3", "burlywood", "burlywood2", "navajowhite", "moccasin", "wheat1", "navajowhite2", "wheat2", "bisque2", "peachpuff2", "bisque", "peachpuff", "lemonchiffon3", "cornsilk3", "lightyellow3", "bisque3", "peachpuff3", "wheat3", "navajowhite3", "tan", "lemonchiffon2", "lemonchiffon", "lightgoldenrodyellow", "cornsilk2", "lightyellow2", "cornsilk", "lightyellow", "antiquewhite2", "antiquewhite", "papayawhip", "ivory", "oldlace", "honeydew", "honeydew2", "ivory2", "azure", "mintcream", "lightcyan", "azure2", "lightcyan2", "lavenderblush2", "mistyrose", "mistyrose2", "lavenderblush", "snow", "linen", "seashell", "seashell2", "snow2", "lightpink3", "pink3", "rosybrown", "rosybrown3", "lightpink2", "pink2", "rosybrown2", "lightpink", "pink", "lightgray", "snow3", "lavenderblush3", "gray", "seashell3", "antiquewhite3", "mistyrose3", "darkgray", "honeydew3", "ivory3", "azure3", "lightcyan3", "thistle3", "lavender", "thistle1", "thistle2", "darkolivegreen4", "olivedrab", "olivedrab4", "gold4", "yellow4", "springgreen4", "palegreen4", "seagreen", "darkgreen", "chartreuse4", "forestgreen", "green4", "yellow", "yellow2", "yellow3", "gold", "gold2", "greenyellow", "olivedrab2", "olivedrab3", "darkolivegreen2", "darkolivegreen3", "lightgreen", "palegreen", "palegreen1", "springgreen", "springgreen2", "springgreen3", "mediumspringgreen", "seagreen1", "seagreen2", "chartreuse3", "green3", "limegreen", "chartreuse2", "chartreuse", "lawngreen", "green", "green2")
        
        
        
        colors_default <- c("blue3", "blue", "magenta3", "magenta", "purple3", "darkorchid3", "purple2", "violetred2", "deeppink3", "deeppink", "hotpink4", "maroon", "maroon4", "plum2", "plum3", "hotpink", "palevioletred2", "palevioletred3", "dodgerblue4", "mediumpurple4", "royalblue4", "darkslateblue", "dodgerblue", "cornflowerblue", "dodgerblue3", "lightslateblue", "mediumslateblue", "mediumpurple2", "mediumpurple3", "slateblue3", "royalblue3", "royalblue2", "midnightblue", "orchid2", "orchid3", "mediumorchid2", "mediumorchid4", "purple4", "orangered", "red2", "orangered3", "red3", "sienna3", "coral2", "coral3", "tomato", "sienna2", "coral", "darkgoldenrod", "gold3", "goldenrod2", "darkgoldenrod3", "orange", "peru", "sandybrown", "tan1", "darkorange3", "chocolate", "chocolate2", "tan4", "salmon4", "orange4", "sienna", "lightcoral", "indianred2", "indianred", "lightsalmon3", "salmon3", "lightsalmon", "salmon", "brown", "darkred", "coral4", "steelblue1", "steelblue2", "deepskyblue", "skyblue3", "deepskyblue3", "steelblue3", "paleturquoise3", "darkslategray3", "paleturquoise", "cadetblue2", "lightskyblue", "lightskyblue2", "skyblue", "lightsteelblue3", "lightskyblue3", "powderblue", "lightblue", "slategray1", "lightsteelblue", "slategray2", "darkslategray", "skyblue4", "deepskyblue4", "steelblue4", "lightblue4", "lightslategray", "lightskyblue4", "lightsteelblue4", "dimgray", "honeydew4", "lavenderblush4", "mistyrose4", "rosybrown4", "lightpink4", "plum4", "thistle4", "aquamarine4", "darkseagreen4", "cyan4", "cadetblue", "paleturquoise4", "cadetblue4", "lemonchiffon4", "burlywood4", "bisque4", "peachpuff4", "wheat4", "darkolivegreen", "lightgoldenrod4", "turquoise1", "turquoise2", "lightseagreen", "mediumturquoise", "cyan3", "darkseagreen2", "darkseagreen", "darkseagreen3", "palegreen3", "mediumseagreen", "seagreen3", "aquamarine3", "aquamarine", "aquamarine2", "darkkhaki", "palegoldenrod", "lightgoldenrod", "burlywood3", "navajowhite", "navajowhite2", "peachpuff2", "bisque", "lemonchiffon3", "cornsilk3", "wheat3", "lemonchiffon2", "lightgoldenrodyellow", "cornsilk2", "lightyellow", "antiquewhite2", "ivory", "oldlace", "honeydew", "honeydew2", "azure", "mintcream", "lightcyan", "azure2", "lightcyan2", "lavenderblush2", "mistyrose", "mistyrose2", "lavenderblush", "linen", "seashell2", "lightpink3", "rosybrown", "lightpink2", "rosybrown2", "lightpink", "lightgray", "lavenderblush3", "gray", "antiquewhite3", "mistyrose3", "darkgray", "honeydew3", "ivory3", "azure3", "lightcyan3", "thistle3", "lavender", "thistle2", "darkolivegreen4", "gold4", "yellow4", "springgreen4", "palegreen4", "darkgreen", "chartreuse4", "forestgreen", "yellow", "yellow2", "yellow3", "gold", "gold2", "olivedrab2", "darkolivegreen2", "darkolivegreen3", "lightgreen", "palegreen",  "springgreen", "springgreen3", "chartreuse3", "green3", "limegreen", "chartreuse2", "green")
        
        
        # set.seed(12344321)
        # length(colors_default)
        # colors_default_mix <- colors_default[sample.int(length(colors_default), length(colors_default), replace = FALSE)]
        # cat(paste0('"', paste(colors_default_mix, collapse='", "'), '"'))
        
        
        colors_default_mix <- c("palevioletred2", "burlywood4", "ivory3", "tomato", "magenta", "coral2", "aquamarine2", "lemonchiffon4", "orchid2", "purple2", "darkolivegreen4", "peachpuff4", "gold", "yellow", "lightgoldenrod", "lightskyblue3", "lightskyblue2", "royalblue3", "deeppink", "plum4", "lightsteelblue", "lightsteelblue3", "purple3", "blue3", "darkolivegreen", "mediumslateblue", "green", "darkgray", "wheat3", "purple4", "darkred", "cadetblue4", "mediumseagreen", "lightskyblue4", "lavenderblush2", "lightsalmon3", "sandybrown", "aquamarine4", "lightgray", "indianred2", "orchid3", "cornsilk2", "hotpink", "dodgerblue", "navajowhite2", "lightseagreen", "skyblue4", "red3", "olivedrab2", "mediumpurple4", "aquamarine3", "lightgoldenrodyellow", "darkorchid3", "indianred", "lightskyblue", "paleturquoise4", "lightpink", "peru", "lightgreen", "lightcoral", "gold4", "royalblue4", "lavenderblush", "lightsalmon", "mediumpurple3", "skyblue3", "dodgerblue3", "cyan3", "lightslateblue", "lightpink4", "brown", "gray", "mistyrose2", "limegreen", "bisque4", "lightcyan3", "rosybrown4", "lightslategray", "maroon4", "azure2", "powderblue", "salmon4", "maroon", "lavenderblush4", "darkkhaki", "peachpuff2", "darkorange3", "springgreen", "mistyrose", "lightcyan2", "lavenderblush3", "turquoise1", "darkgreen", "mistyrose4", "coral4", "red2", "dimgray", "lightblue4", "midnightblue", "chocolate2", "cornsilk3", "linen", "orangered3", "steelblue4", "lemonchiffon2", "deepskyblue3", "green3", "cadetblue", "slategray2", "palegreen", "thistle2", "darkolivegreen2", "chartreuse4", "chartreuse3", "darkseagreen3", "deepskyblue", "lightblue", "coral3", "lightpink3", "chartreuse2", "skyblue", "bisque", "springgreen4", "tan4", "mediumorchid2", "darkseagreen4", "orange", "azure", "yellow2", "slateblue3", "tan1", "plum2", "deeppink3", "violetred2", "goldenrod2", "slategray1", "darkseagreen2", "antiquewhite2", "palegreen4", "aquamarine", "salmon3", "oldlace", "springgreen3", "salmon", "palegreen3", "darkgoldenrod", "azure3", "yellow3", "ivory", "paleturquoise3", "cyan4", "lemonchiffon3", "lightgoldenrod4", "darkslateblue", "sienna", "honeydew2", "mediumorchid4", "honeydew", "royalblue2", "palegoldenrod", "honeydew4", "lavender", "forestgreen", "cornflowerblue", "mediumpurple2", "magenta3", "sienna3", "mediumturquoise", "rosybrown2", "gold3", "steelblue1", "lightpink2", "gold2", "wheat4", "seagreen3", "steelblue3", "thistle4", "honeydew3", "palevioletred3", "yellow4", "blue", "lightcyan", "burlywood3", "lightsteelblue4", "hotpink4", "paleturquoise", "steelblue2", "darkolivegreen3", "rosybrown", "lightyellow", "mistyrose3", "darkslategray3", "darkseagreen", "navajowhite", "deepskyblue4", "orange4", "coral", "seashell2", "plum3", "thistle3", "dodgerblue4", "turquoise2", "darkslategray", "chocolate", "antiquewhite3", "darkgoldenrod3", "cadetblue2", "sienna2", "mintcream", "orangered")
        
        stopifnot(length(levels_x) <= length(colors_default_mix))
        
        out <- colors_default_mix[seq_len(length(levels_x))]
        
        names(out) <- levels_x
        
        
      }else if(palette == "paired"){
        
        ### paired
        
        colors_default <- c("#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", "#6A3D9A", "#FFFF99", "#B15928")
        
        # barplot(rep(1, length(colors_default)), col = colors_default)
        
        
        stopifnot(length(levels_x) <= 12)
        
        out <- colors_default[1:length(levels_x)]
        names(out) <- levels_x
        
        
      }else if(palette %in% c("BrBG", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral")){
        ### diverging palettes
        n <- 11  
        
        ### Skip the center light colors and extremes
        
        out <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(n, palette)[-c(1, 5, 6, 7, n)])(length(levels_x))
        
        
      }else if(palette %in% c("Blues", "BuGn", "BuPu", "GnBu", "Greens", "Greys", "Oranges", "OrRd", "PuBu", "PuBuGn", "PuRd", "Purples", "RdPu", "Reds", "YlGn", "YlGnBu", "YlOrBr", "YlOrRd")){
        
        ### sequential palettes
        
        n <- 9
        
        ### Skip colors at the extremes 
        if(length(levels_x) == 1){
          skip_colors <- c(2:5, n-2, n-1)
        }else if(length(levels_x) == 2){
          skip_colors <- c(2, 3, 4, n-1)
        }else if(length(levels_x) <= 4){
          skip_colors <- c(2, n-1)
        }else{
          skip_colors <- NULL
        }
        
        
        out <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(n, palette)[-c(1, skip_colors, n)])(length(levels_x))
        
        
      }else if(palette %in% c("Oranges2", "Blues2")){
        
        palette_colors <- list(
          "Oranges2" = grDevices::colorRampPalette(c("white", "#F69C26"))(9)[-c(1:4)],
          "Blues2" = grDevices::colorRampPalette(c("white", "#297cbe"))(9)[-c(1:4)]
        )
        
        out <- grDevices::colorRampPalette(palette_colors[[palette]])(length(levels_x))
        
        # barplot(rep(1, length(out)), col = out)
        
        
        
      }else{
        
        colors_default <- grDevices::colorRampPalette(c("white", palette))(9)[-c(1:3)]
        
        out <- grDevices::colorRampPalette(colors_default)(length(levels_x))
        
        # barplot(rep(1, length(out)), col = out)
        
        
      }
      
      
      
      
      if(rev){
        out <- rev(out)
      }
      
      names(out) <- levels_x
      
      
      # barplot(rep(1, length(out)), col = out)
      
      
    }else{
      out <- grDevices::colorRampPalette(palette)(length(levels_x))
      names(out) <- levels_x
    }
    
    
    
    
    # barplot(rep(1, length(out)), col = out)
    
    
  }else{
    
    stopifnot(length(colors) >= length(levels_x))
    
    if(is.null(names(colors))){
      out <- colors[seq_along(levels_x)]
      names(out) <- levels_x
    }else{
      stopifnot(all(levels_x %in% names(colors)))
      out <- colors[levels_x]
    }
    
    ### Colors have to be unique for ggsurvplot. Otherwise, it does not work.
    if(!allow_duplicated){
      stopifnot(sum(duplicated(out)) == 0)
    }
    
    
  }
  
  
  return(out)
  
  
}




#' @rdname format_colors_cat
#' @export
format_colors <- function(x, colors = NULL, palette = NULL, rev = FALSE, allow_duplicated = TRUE){
  
  format_colors_cat(x, colors = colors, palette = palette, rev = rev, allow_duplicated = allow_duplicated)
  
}






#' @rdname format_colors_cat
#' @param strata Vector of categorical values of stratification groups.
#' @param palette List of length corresponding the number of levels in strata with colors or names of RColorBrewer palettes. E.g. `list("Blues", "Oranges", "Greens", "Purples", "Reds", "Greys")`
#' @export
format_colors_cat_strata <- function(x, strata = NULL, palette = NULL, rev = FALSE){
  
  
  x <- x[!is.na(x)]
  
  if(!is.factor(x)){
    x <- factor(x, levels = unique(x))
  }
  
  levels_x <- levels(x)
  
  
  
  if(is.null(strata)){
    strata <- "strata_dummy"
  }
  
  strata <- strata[!is.na(strata)]
  
  if(!is.factor(strata)){
    strata <- factor(strata, levels = unique(strata))
  }
  
  levels_strata <- levels(strata)
  
  
  if(is.null(palette)){
    
    palette <- list("Blues", "Oranges", "Greens", "Purples", "Reds", "Greys")[seq_along(levels_strata)]
    
  }else{
    
    stopifnot(length(palette) == length(levels_strata))
    
  }
  
  
  
  out <- lapply(seq_along(levels_strata), function(i){
    # i = 1 
    
    x <- paste0(levels_strata[i], ", ", levels_x)
    
    
    out <- format_colors_cat(x, palette = palette[[i]], rev = rev, allow_duplicated = FALSE)
    
    
  })
  
  
  out <- unlist(out, use.names = TRUE)
  
  names(out) <- gsub("^strata_dummy, ", "", names(out))
  
  
  out
  
  
  
}




#' Compute upper whisker 
#' 
#' @param x Vector with data
#' 
#' @return Upper whisker
#' @details For the info about whiskers see https://www.r-bloggers.com/2012/06/whisker-of-boxplot/
#' 
#' @export
compute_upper_whisker <- function(x, range = 1.5){
  
  
  first_quartile <- quantile(x, probs = 0.25, na.rm = TRUE)
  third_quartile <- quantile(x, probs = 0.75, na.rm = TRUE)
  
  IQR <- third_quartile - first_quartile
  
  upper_whisker <- as.numeric(third_quartile + range * IQR)
  
  
}


#' Compute lower whisker 
#' 
#' @param x Vector with data
#' 
#' @return Lower whisker
#' @details For the info about whiskers see https://www.r-bloggers.com/2012/06/whisker-of-boxplot/
#' 
#' @export
compute_lower_whisker <- function(x, range = 1.5){
  
  
  first_quartile <- quantile(x, probs = 0.25, na.rm = TRUE)
  third_quartile <- quantile(x, probs = 0.75, na.rm = TRUE)
  
  IQR <- third_quartile - first_quartile
  
  lower_whisker <- as.numeric(first_quartile - range * IQR)
  
  
}



#' Compute trimming values and trim data to a specified range
#' 
#' @param x Vector with data
#' @param centered Logical. If the data is z-score scaled, the trimming ranges are made symmetric. Default value FALSE.
#' 
#' @return Vector of length two with data range that should be used for trimming.
#' 
#' @export
compute_trim_values <- function(x, centered = FALSE, trim_prop = NULL, trim_range = NULL, ceiling = FALSE){
  
  
  if(centered){
    
    
    if(is.null(trim_prop) && is.null(trim_range)){
      max_abs_value <- max(abs(range(x, na.rm = TRUE)))
    }
    
    
    if(!is.null(trim_range)){
      ### Use whiskers
      
      if(length(trim_range) == 1){
        trim_range <- c(trim_range, trim_range)
      }
      
      lower_whisker <- compute_lower_whisker(x, range = trim_range[1])
      upper_whisker <- compute_upper_whisker(x, range = trim_range[2])
      
      max_abs_value <- max(abs(c(lower_whisker, upper_whisker)))
    }
    
    
    if(!is.null(trim_prop)){
      ### Use quantiles 
      
      if(length(trim_prop) == 1){
        trim_prop <- c(trim_prop, 1 - trim_prop)
      }
      
      max_abs_value <- max(abs(quantile(x, probs = c(trim_prop[1], trim_prop[2]), na.rm = TRUE)))
    }
    
    
    if(ceiling){
      max_abs_value <- ceiling(max_abs_value)
    }
    
    
    trim_values <- c(-max_abs_value, max_abs_value)
    
    
  }else{
    
    
    
    if(is.null(trim_prop) && is.null(trim_range)){
      range_value <- range(x, na.rm = TRUE)
    }
    
    
    if(!is.null(trim_range)){
      ### Use whiskers
      
      if(length(trim_range) == 1){
        trim_range <- c(trim_range, trim_range)
      }
      
      lower_whisker <- compute_lower_whisker(x, range = trim_range[1])
      upper_whisker <- compute_upper_whisker(x, range = trim_range[2])
      
      range_value <- c(lower_whisker, upper_whisker)
    }
    
    
    if(!is.null(trim_prop)){
      ### Use quantiles 
      
      if(length(trim_prop) == 1){
        trim_prop <- c(trim_prop, 1 - trim_prop)
      }
      
      range_value <- quantile(x, probs = c(trim_prop[1], trim_prop[2]), na.rm = TRUE)
    }
    
    if(ceiling){
      range_value <- c(floor(range_value[1]), ceiling(range_value[2]))
    }
    
    trim_values <- c(range_value[1], range_value[2])
    
  }
  
  trim_values
  
}




#' @rdname compute_trim_values
#' @param x Vector or matrix of continuous values that should be trimmed.
#' @param trim_values Vector of length two defining the upper and lower limits, respectively. If NULL, trim_prop or trim_range must be specified to derive the trim_values using compute_trim_values. 
#' 
#' @return Vector or matrix where the values outside the specified range are squished.
#' 
#' @examples 
#' 
#' set.seed(123)
#' 
#' x <- rnorm(10)
#' 
#' x
#' 
#' apply_trim_values(x, trim_values = 1)
#' 
#' @export
apply_trim_values <- function(x, centered = FALSE, trim_values = NULL, trim_prop = NULL, trim_range = NULL, ceiling = FALSE){
  
  
  x_orig <- x
  
  x <- c(x)
  x <- x[!is.na(x)]
  
  
  # ---------------------------------------------------------------------
  # Define trim values
  # ---------------------------------------------------------------------
  
  
  if(centered){
    
    
    if(is.null(trim_values)){
      trim_values <- compute_trim_values(x, centered = centered, trim_prop = trim_prop, trim_range = trim_range, ceiling = ceiling)
    }else{
      max_abs_value <- max(abs(trim_values))
      trim_values <- c(-max_abs_value, max_abs_value)
    }
    
    
  }else{
    
    
    if(is.null(trim_values)){
      trim_values <- compute_trim_values(x, centered = centered, trim_prop = trim_prop, trim_range = trim_range, ceiling = ceiling)
    }
    
    
  }
  
  # ---------------------------------------------------------------------
  # Do trimming
  # ---------------------------------------------------------------------
  
  x_out <- x_orig
  
  x_out[x_out < trim_values[1]] <- trim_values[1]
  x_out[x_out > trim_values[2]] <- trim_values[2]
  
  return(x_out)
  
  
}






#' Generate colors for ComplexHeatmap for continuous variables 
#' 
#' @param x Vector or matrix of continuous values for which we want to specify colors.
#' @param centered Logical. Default value TRUE.
#' @param palette Vector of at least two colors used to create a color palette with 'colorRampPalette' or name of a RColorBrewer palette e.g. "Oranges", "Spectral".
#' 
#' @return Vector of unique colors for all unique values of x.
#' 
#' @examples 
#' 
#' x <- rnorm(20)
#' 
#' palette <- "Spectral"
#' 
#' format_colors_num(x, trim_values = 2.5)
#' 
#' @export
format_colors_num <- function(x, centered = TRUE, palette = NULL, rev = FALSE, trim_values = NULL, trim_prop = NULL, trim_range = NULL, ceiling = FALSE){
  
  
  x <- c(x)
  x <- x[!is.na(x)]
  
  
  # ---------------------------------------------------------------------
  # Define colors
  # ---------------------------------------------------------------------
  
  
  
  if(is.null(palette)){
    if(centered){
      # palette <- c("dodgerblue1", "dodgerblue3", "dodgerblue4", "black", "firebrick4", "firebrick3", "firebrick1")
      # barplot(rep(1, length(palette)), col = palette)
      
      palette <- c(rev(RColorBrewer::brewer.pal(9, "Blues")), RColorBrewer::brewer.pal(9, "Oranges"))
      
    }else{
      palette <- grDevices::hcl.colors(10, palette = "viridis")
    }
  }
  
  
  if(length(palette) == 1){
    
    if(palette %in% c("Blues", "BuGn", "BuPu", "GnBu", "Greens", "Greys", "Oranges", "OrRd", "PuBu", "PuBuGn", "PuRd", "Purples", "RdPu", "Reds", "YlGn", "YlGnBu", "YlOrBr", "YlOrRd")){
      
      n <- 9
      
      # colors <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(n, palette)[-c(1, n)])(n)
      colors <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(n, palette))(n)
      
    }else{
      
      n <- 11  
      
      # colors <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(n, palette)[-c(1, n)])(n)
      colors <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(n, palette))(n)
      
    }
    
    # barplot(rep(1, length(colors)), col = colors)
    
    
  }else{
    
    colors <- palette
    
  }
  
  
  if(rev){
    colors <- rev(colors)
  }
  
  
  # ---------------------------------------------------------------------
  # Define trim values and color breaks 
  # ---------------------------------------------------------------------
  
  
  if(centered){
    
    
    if(is.null(trim_values)){
      trim_values <- compute_trim_values(x, centered = centered, trim_prop = trim_prop, trim_range = trim_range, ceiling = ceiling)
    }else{
      max_abs_value <- max(abs(trim_values))
      trim_values <- c(-max_abs_value, max_abs_value)
    }
    
    
  }else{
    
    
    if(is.null(trim_values)){
      trim_values <- compute_trim_values(x, centered = centered, trim_prop = trim_prop, trim_range = trim_range, ceiling = ceiling)
    }
    
    
  }
  
  
  breaks <- seq(trim_values[1], trim_values[2], length.out = length(colors))
  
  out <- circlize::colorRamp2(breaks, colors)
  
  
  return(out)
  
  
}














#' Calculate break time used in KM plots
#' 
#' @param x Vector with time-to-event data.
#' @param n_breaks Number of breaks.
#' @examples 
#' \dontrun{
#' data(bdata)
#' 
#' calculate_break_time(bdata$PFS)
#' }
#' @keywords internal
calculate_break_time <- function(x, n_breaks = 10){
  
  # break_time_by <- max(x, na.rm = TRUE) %/% n_breaks
  
  time_max <- max(x, na.rm = TRUE)
  
  time_by_original <- time_max / n_breaks
  
  breaks <- c(0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000)
  
  time_by_rounded <- cut(time_by_original, breaks = c(0, breaks), labels = breaks)
  time_by_rounded <- as.numeric(as.character(time_by_rounded))
  
  time_by_rounded
  
}







#' Density Values for Smooth Density Plots
#' 
#' It produces a vector containing density values which encode the local densities at each point in a scatterplot.
#' 
#' @details It is based on function densCols from grDevices.
#' @return Vector with density level.
#' @export
densVals <- function(x, y = NULL, nbin = 128, bandwidth){
  
  xy <- grDevices::xy.coords(x, y, setLab = FALSE)
  
  select <- is.finite(xy$x) & is.finite(xy$y)
  
  x <- cbind(xy$x, xy$y)[select, ]
  
  map <- grDevices:::.smoothScatterCalcDensity(x, nbin, bandwidth)
  
  mkBreaks <- function(u) u - diff(range(u))/(length(u) - 1)/2
  
  xbin <- cut(x[, 1], mkBreaks(map$x1), labels = FALSE)
  
  ybin <- cut(x[, 2], mkBreaks(map$x2), labels = FALSE)
  
  dens <- map$fhat[cbind(xbin, ybin)]
  
  dens[is.na(dens)] <- 0
  
  colpal <- cut(dens, length(dens), labels = FALSE)
  
  vals <- rep(NA, length(select))
  
  vals[select] <- colpal
  
  vals
  
}



##############################################################################
# Renumber clusters 
##############################################################################





setClusterColors <- function(past_ct, ct, colorList, colorU, method = "original", threshold = 70){
  
  
  stopifnot(method %in% c("original", "new"))
  
  
  if(length(colorList) == 0){
    
    newColors = colorU[ct]
    colori = max(ct)
    
  }else if(method == "original"){ # Here we look where the majority of old cluster goes 
    
    newColors <- NULL
    colori <- colorList[["colori"]]
    
    m <- proportions(table(past_ct = past_ct, ct = ct), margin = 1) * 100
    m
    
    for(tci in 1:ncol(m)){ # for each new cluster
      # tci = 1
      
      maxC <- max(m[, tci])
      
      pci <- which(m[, tci] == maxC) 
      
      
      if(length(pci) == 1 & max(m[pci, ]) == maxC & sum(m[pci, ] == maxC) == 1){
        
        #if new column maximum is unique, same cell is row maximum and is also unique
        ##Note: the greatest of the prior clusters' members are the greatest in a current cluster's members.
        newColors[which(ct == tci)] <- unique(colorList[["newColors"]][which(past_ct == pci)]) # one value
        
      }else{ # Add new color
        
        colori <- colori + 1
        newColors[which(ct == tci)] <- colorU[colori]
        
      }
      
    }
    
  }else{ # Here we look at the main composition of the new cluster 
    
    newColors <- NULL
    colori <- colorList[["colori"]]
    
    m <- proportions(table(past_ct = past_ct, ct = ct), margin = 2) * 100
    m
    
    
    for(tci in 1:ncol(m)){ # for each new cluster
      # tci = 1
      
      maxC <- max(m[, tci])
      
      pci <- which(m[, tci] == maxC) 
      
      
      if(maxC > threshold & length(pci) == 1 & max(m[pci, ]) == maxC & sum(m[pci, ] == maxC) == 1){
        
        # if new column maximum is unique, same cell is row maximum and is also unique
        ##Note: the greatest of the prior clusters' members are the greatest in a current cluster's members.
        newColors[which(ct == tci)] <- unique(colorList[["newColors"]][which(past_ct == pci)]) # one value
        
      }else{ # Add new color
        
        colori <- colori + 1
        newColors[which(ct == tci)] <- colorU[colori]
        
      }
      
    }
    
    
    
  }
  
  
  unique_newColors <- unique(newColors)
  names(unique_newColors) <- unique(ct)
  
  unique_newColors <- unique_newColors[order(unique(ct))]
  
  
  return(list(newColors = newColors, colori = colori, unique_newColors = unique_newColors))
  
  
}






#' Renumber clusters based on their splitting so they can be traced 
#' 
#' @param x Data frame with clustering, where columns are ordered by non-decreasing rank of clustering.
#' @export
wrapper_renumber_clusters <- function(x, method = "new", threshold = 70){
  
  
  x <- mutate_all(x, factor)
  x <- mutate_all(x, as.numeric)
  
  
  ranks <- unlist(lapply(x, function(xx){
    length(unique(xx[!is.na(xx)]))
  }))
  
  original_col_order <- colnames(x)
  
  x <- x[, order(ranks)]
  
  
  max_rank <- max(ranks)
  
  colorU <- 1:(max_rank * max_rank)
  
  
  colorList <- list(list())
  
  
  for(i in 1:ncol(x)){
    # i = 1
    
    # print(i)
    
    if(i == 1){
      past_ct <- NULL
    }else{
      past_ct <- x[, i - 1]  
    }
    
    ct <- x[, i]
    
    
    colorList[[i + 1]] <- setClusterColors(past_ct = past_ct, ct = ct, colorList = colorList[[i]], colorU = colorU, method = method, threshold = threshold)
    
    # print(colorList[[i + 1]])
    
    
  }
  
  
  
  out <- lapply(colorList[-1], function(x){
    x[[1]]
  })
  
  out <- data.frame(out)
  colnames(out) <- colnames(x)
  
  
  out <- out[, original_col_order]
  
  return(out)
  
  
}










































